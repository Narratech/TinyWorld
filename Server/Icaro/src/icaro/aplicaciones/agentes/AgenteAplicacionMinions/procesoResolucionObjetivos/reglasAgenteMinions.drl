import icaro.infraestructura.recursosOrganizacion.recursoTrazas.ItfUsoRecursoTrazas;
import icaro.infraestructura.recursosOrganizacion.recursoTrazas.imp.componentes.InfoTraza;
import icaro.infraestructura.entidadesBasicas.procesadorCognitivo.*;
import icaro.infraestructura.patronAgenteCognitivo.procesadorObjetivos.gestorTareas.ItfGestorTareas;
import icaro.infraestructura.entidadesBasicas.PerformativaUsuario;
import icaro.infraestructura.entidadesBasicas.comunicacion.*
import icaro.aplicaciones.agentes.AgenteAplicacionMinions.objetivos.*;
import icaro.aplicaciones.informacion.gestionCitas.*;
import icaro.aplicaciones.informacion.minions.*;
import icaro.aplicaciones.agentes.AgenteAplicacionMinions.tareas.*;

global ItfGestorTareas gestorTareas;
global ItfUsoRecursoTrazas recursoTrazas;
global String agentId;

rule "Creacion de los objectivos iniciales"
when 
then 
TareaSincrona tarea = gestorTareas.crearTareaSincrona(InicializarInfoWorkMem.class);
    tarea.ejecutar();
recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName()); 
end
// =======================================================================
//Reglas de focalizacion de objetivos.
rule "Regla de focalizacion de explorar"
 when
    f:Focus(foco == null )
    obj:Explorar()
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end

// =======================================================================
//Reglas de generacion de objetivos.
rule "Regla de generacion de explorar"
 when
    f:Focus(foco == null)
    notif:Notificacion(identInterlc:identNotificador, tipoNotificacion==VocabularioControlMinions.NombreTipoNoticacionExplorar)
 then
 	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : Generar objetivo de exploracion",InfoTraza.NivelTraza.debug));
 	TareaSincrona tarea = gestorTareas.crearTareaSincrona(GenerarObjetivoExploracion.class);
 	tarea.ejecutar(notif);
 	retract(notif);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

// =============================== exploracion =======================================
// Reclas de realizacion de eploracion
rule "Regla de realizacion de explorar"
 when
 	obj:Explorar(zon:zone, state==Objetivo.PENDING)
    f:Focus(foco == obj)
 then
 	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : Moverse ",InfoTraza.NivelTraza.debug));
 	TareaSincrona tarea = gestorTareas.crearTareaSincrona(SeleccionarZonaExploracion.class);
 	tarea.ejecutar(zon);
    recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Realizando el objetivo : "+obj.getgoalId()+"  Ejecutando la tarea : "+ tarea.getIdentTarea() ,InfoTraza.NivelTraza.debug));
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de finalizacion del movimiento y observacion"
 when
 	obj:Explorar(zon:zone, state==Objetivo.PENDING)
    f:Focus(foco == obj)
    event:GameEvent(name=="event finished")
 then
 	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : Observar ",InfoTraza.NivelTraza.debug));
 	TareaSincrona tarea = gestorTareas.crearTareaSincrona(Observar.class);
 	tarea.ejecutar();
 	retract(event);
    recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Realizando el objetivo : "+obj.getgoalId()+"  Ejecutando la tarea : "+ tarea.getIdentTarea() ,InfoTraza.NivelTraza.debug));
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de finalizacion de la observacion"
 when
 	obj:Explorar(zon:zone, state==Objetivo.PENDING)
    f:Focus(foco == obj)
    event:GameEvent(name=="observation finished")
 then
 	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : almacenar informacion nueva ",InfoTraza.NivelTraza.debug));
 	TareaSincrona tarea = gestorTareas.crearTareaSincrona(AlmacenarInformacionNueva.class);
 	tarea.ejecutar();
 	retract(event);
    recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Realizando el objetivo : "+obj.getgoalId()+"  Ejecutando la tarea : "+ tarea.getIdentTarea() ,InfoTraza.NivelTraza.debug));
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

// ========================= MOVIMIENTO ==============================

rule "AUX generar alcanzar posici√≥n test"
 when
 	event:GameEvent(name.equals("AlcanzarPosicion"))
 	mi:MinionInfo()
 	eval ( event.getParameter("entity").equals(mi.getInstanceId()) )
 then
    Objetivo ap = new AlcanzarPosicion((Coord) event.getParameter("cell"), (Integer) event.getParameter("distance"));
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end


rule "Regla de focalizacion de alcanzar posicion"
 when
    obj:AlcanzarPosicion(state==Objetivo.PENDING)
    f:Focus(foco == null || foco==obj.getParent())
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end

rule "Regla de resolucion de alcanzar posicion"
 when
    obj:AlcanzarPosicion(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
 then
    obj.setState(Objetivo.SOLVING);
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Moverse.class);
 	tarea.ejecutar(mi, mc, obj.getCoord(), obj.getDistance());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(obj);
end

rule "Regla de consecucion de alcanzar posicion"
 when
    obj:AlcanzarPosicion(state==Objetivo.SOLVING)
    f:Focus(foco==obj)
    report:GameEvent(name.equalsIgnoreCase("event finished"))
    mi:MinionInfo()
    eval(((GameEvent)report.getParameter("event")).getName().equals("move") && ((GameEvent)report.getParameter("event")).getParameter("entity").equals(mi.getInstanceId()) )
 then
  	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : Evaluar el resultado del movimiento ",InfoTraza.NivelTraza.debug));
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(EvaluaResultadoMovimiento.class);
 	tarea.ejecutar(obj, mi, report);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de finalizacion correcta de alcanzar posicion"
 when
    obj:AlcanzarPosicion(state==Objetivo.SOLVED)
    f:Focus(foco==obj)
 then
    f.setFoco(obj.getParent());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    update(f);
    retract(obj);
end

rule "Regla de finalizacion incorrecta de alcanzar posicion"
 when
    obj:AlcanzarPosicion(state==Objetivo.FAILED)
    f:Focus(foco==obj)
 then
 	// TODO resolver esta regla al darse error
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

// ========================= recoger OBJETO ==============================

rule "AUX generar recoger objeto test"
 when
 	event:GameEvent(name.equals("RecogerObjeto"))
 	mi:MinionInfo()
 	eval ( event.getParameter("minion_id").equals(mi.getInstanceId()) )
 then
    Objetivo ap = new RecogerObjeto((ItemData) event.getParameter("item"));
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end


rule "Regla de focalizacion de recoger objeto"
 when
    obj:RecogerObjeto(state==Objetivo.PENDING)
    f:Focus(foco == null || foco==obj.getParent())
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end

rule "Regla de resolucion de recoger objeto cercano"
 when
    obj:RecogerObjeto(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    eval ( obj.getItem().canPick(mi.getCoords()) )
 then
    obj.setState(Objetivo.SOLVING);
    update(obj);
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Recoger.class);
 	tarea.ejecutar(mi, mc, obj.getItem());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
     recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," ESTADO ACTUAL: " + f.getFoco());
end

rule "Regla de resolucion de recoger objeto lejano"
 when
    obj:RecogerObjeto(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    not ( eval ( obj.getItem().canPick(mi.getCoords()) ) )
 then
    Subobjetivo ap = new AlcanzarPosicion( obj.getItem().getCoords(), 1);
    ap.setParent(obj);
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de consecucion de recoger objeto"
 when
    obj:RecogerObjeto(state==Objetivo.SOLVING)
    f:Focus(foco==obj)
    report:GameEvent(name.equalsIgnoreCase("event finished"))
    mi:MinionInfo()
    eval(((GameEvent)report.getParameter("event")).getName().equals("pick item") && ((GameEvent)report.getParameter("event")).getParameter("minion_id").equals(mi.getInstanceId()) )
 then
  	recursoTrazas.aceptaNuevaTraza(new InfoTraza(agentId,"Ejecuto la tarea : Evaluar el resultado de recoger objeto ",InfoTraza.NivelTraza.debug));
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(EvaluaResultadoRecoger.class);
 	tarea.ejecutar(obj, mi, report);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de finalizacion correcta de recoger objeto"
 when
    obj:RecogerObjeto(state==Objetivo.SOLVED)
    f:Focus(foco==obj)
 then
    f.setFoco(obj.getParent());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    retract(obj);
end

rule "Regla de finalizacion incorrecta de recoger objeto"
 when
    obj:RecogerObjeto(state==Objetivo.FAILED)
    f:Focus(foco==obj)
 then
 	// TODO resolver esta regla al darse error
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

// ========================= DEPOSITAR OBJETO ==============================

rule "AUX generar depositar objeto test"
 when
 	event:GameEvent(name.equals("DepositarObjeto"))
 	mi:MinionInfo()
 	eval ( event.getParameter("minion_id").equals(mi.getInstanceId()) )
 then
    Objetivo ap = new DepositarObjeto((ItemData) event.getParameter("item"), (Coord) event.getParameter("destination"));
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end


rule "Regla de focalizacion de depositar objeto"
 when
    obj:DepositarObjeto(state==Objetivo.PENDING)
    f:Focus(foco == null || foco==obj.getParent())
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end

rule "Regla de resolucion de depositar objeto cercano"
 when
    obj:DepositarObjeto(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    eval ( obj.isNear(mi.getCoords()) )
 then
    obj.setState(Objetivo.SOLVING);
    update(obj);
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Depositar.class);
 	tarea.ejecutar(mi, mc, obj.getItem(), obj.getDestination());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
     recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," ESTADO ACTUAL: " + f.getFoco());
end

rule "Regla de resolucion de depositar objeto lejano"
 when
    obj:DepositarObjeto(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
    not ( eval ( obj.isNear(mi.getCoords()) ) )
 then
    Subobjetivo ap = new AlcanzarPosicion( obj.getDestination(), 1);
    ap.setParent(obj);
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end

rule "Regla de consecucion de depositar objeto"
 when
    obj:DepositarObjeto(state==Objetivo.SOLVING)
    f:Focus(foco==obj)
    report:GameEvent(name.equalsIgnoreCase("event finished"))
    mi:MinionInfo()
    eval(((GameEvent)report.getParameter("event")).getName().equals("drop item") && ((GameEvent)report.getParameter("event")).getParameter("minion_id").equals(mi.getInstanceId()) )
 then
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    obj.setSolved();
    update(obj);
end

rule "Regla de finalizacion de depositar objeto"
 when
    obj:DepositarObjeto(state==Objetivo.SOLVED)
    f:Focus(foco==obj)
 then
    f.setFoco(obj.getParent());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    retract(obj);
end

// ========================= OBSERVAR ENTORNO ==============================

rule "AUX generar observar entorno"
 when
 	event:GameEvent(name.equals("ObservarEntorno"))
 	mi:MinionInfo()
 	eval ( event.getParameter("minion_id").equals(mi.getInstanceId()) )
 then
    Objetivo ap = new ObservarEntorno();
    insert(ap);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end


rule "Regla de focalizacion de observar entorno"
 when
    obj:ObservarEntorno(state==Objetivo.PENDING)
    f:Focus(foco == null || foco==obj.getParent())
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end

rule "Regla de resolucion de observar entorno"
 when
    obj:ObservarEntorno(state==Objetivo.PENDING)
    mi:MinionInfo()
    mc:MinionContext()
    f:Focus(foco==obj)
 then
    obj.setState(Objetivo.SOLVING);
    update(obj);
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Observar.class);
 	tarea.ejecutar(mi,mc);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," ESTADO ACTUAL: " + f.getFoco());
end

rule "Regla de consecucion de observar entorno"
 when
    obj:ObservarEntorno(state==Objetivo.SOLVING)
    f:Focus(foco==obj)
    report:GameEvent(name.equalsIgnoreCase("observereport"))
    mi:MinionInfo()
    eval ( report.getParameter("minion_id").equals(mi.getInstanceId()) )
 then
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(AlmacenarObservado.class);
 	tarea.ejecutar(mi,report);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," ESTADO ACTUAL: " + f.getFoco());
    obj.setState(Objetivo.SOLVED);
    update(obj);
end

rule "Regla de finalizacion de observar entorno"
 when
    obj:ObservarEntorno(state==Objetivo.SOLVED)
    f:Focus(foco==obj)
 then
    f.setFoco(obj.getParent());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId,"Nuevo Foco : " + f.getFoco());
    retract(obj);
end

// ========================= Obtencion de un objeto ==============================

/*rule "Regla de focalizacion de obtener objeto"
 when
    obj:ObtenerObjeto(state==Objetivo.PENDING)
    f:Focus(foco==null)
 then
    f.setFoco(obj);
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
end


rule "Regla de resolucion de ObtenerObjeto si conozco informacion del objeto"
 when
    obj:ObtenerObjeto(o:objeto,state==Objetivo.PENDING)
    f:Focus(foco==obj)
    i:Item(name==o)
 then
    f.setFoco(obj);
    obj.setState(Objetivo.SOLVING);
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Moverse.class);
 	tarea.ejecutar(i, obj.getDistance());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
    update(f);
    update(obj);
end

rule "Regla de resolucion de ObtenerObjeto si no conozco informacion"
 when
    obj:ObtenerObjeto(o:objeto,state==Objetivo.PENDING)
    f:Focus(foco == obj)
    not ( Item(name==o) )
 then
    TareaSincrona tarea = gestorTareas.crearTareaSincrona(Observar.class);
 	tarea.ejecutar(i, obj.getDistance());
    recursoTrazas.aceptaNuevaTrazaEjecReglas(agentId," EJECUTO LA REGLA: " + drools.getRule().getName());
end*/

rule "Actualiza el estado del minion con alta prioridad"
salience +10
when
	event:GameEvent(name.equalsIgnoreCase("update minion"))
	mi:MinionInfo()
	eval ( ((MinionInfo)event.getParameter("minion")).getInstanceId() == mi.getInstanceId() )
then
	retract(mi);
	insert((MinionInfo)event.getParameter("minion"));
	retract(event);
end

rule "Limpieza de evento en memoria con baja prioridad"
salience -10 
when
	event:GameEvent()
then
	retract(event);
end

